#!/usr/bin/env python3
import os
import sys
import socket
import subprocess
import json
import requests
import time
import threading
from concurrent.futures import ThreadPoolExecutor

# Colors
GREEN = '\033[92m'
BLUE = '\033[94m'
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
WHITE = '\033[97m'
RESET = '\033[0m'

def clear_screen():
    os.system('clear' if os.name == 'posix' else 'cls')

def print_banner():
    clear_screen()
    print(f"{GREEN}")
    print(f" /$$$$$$ /$$$$$$$  /$$   /$$ /$$   /$$ /$$$$$$$ ")
    print(f"|_  $$_/| $$__  $$| $$  | $$| $$  | $$| $$__  $$")
    print(f"  | $$  | $$  \ $$| $$  | $$| $$  | $$| $$  \ $$")
    print(f"  | $$  | $$$$$$$/| $$$$$$$$| $$  | $$| $$$$$$$ ")
    print(f"  | $$  | $$____/ | $$__  $$| $$  | $$| $$__  $$")
    print(f"  | $$  | $$      | $$  | $$| $$  | $$| $$  \ $$")
    print(f" /$$$$$$| $$      | $$  | $$|  $$$$$$/| $$$$$$$/")
    print(f"|______/|__/      |__/  |__/ \______/ |_______/ ")
    print(f"                                                ")
    print(f"                                                ")
    print(f"                                                {RESET}")
    print(f"{YELLOW}                  Made by marzi tools{RESET}")
    print()

def print_menu():
    print(f"{CYAN}---------------------- Tools ----------------------{RESET}")
    print(f"[{GREEN}1{RESET}] IP info")
    print(f"[{GREEN}2{RESET}] Port Scan")
    print(f"[{GREEN}3{RESET}] Service detection")
    print(f"[{GREEN}4{RESET}] ARP scanning")
    print(f"[{GREEN}5{RESET}] Ping Sweep")
    print(f"[{GREEN}6{RESET}] NetStat")
    print(f"[{GREEN}7{RESET}] TraceRoute")
    print()
    print(f"{YELLOW}----------------------------- Advanced--------------------------------{RESET}")
    print(f"[{GREEN}8{RESET}] {YELLOW}Advanced IP Scan                  #API#{RESET}")
    print(f"[{GREEN}9{RESET}] OS Detection")
    print(f"[{GREEN}10{RESET}] Get MAC")
    print(f"[{GREEN}11{RESET}] Service Info")
    print(f"[{GREEN}12{RESET}] Whois lookup")
    print()
    print(f"{CYAN}----------------------------- Others----------------------------{RESET}")
    print(f"[{GREEN}13{RESET}] Nmap scan")
    print(f"[{GREEN}14{RESET}] TCP Scan")
    print(f"[{GREEN}15{RESET}] UDP Scan")
    print(f"[{GREEN}16{RESET}] Trace Path")
    print(f"[{GREEN}17{RESET}] Version")
    print()

def ip_info():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        # Validate IP address
        socket.inet_aton(ip)
        
        # Get IP information from ip-api.com
        url = f"http://ip-api.com/json/{ip}"
        response = requests.get(url)
        data = response.json()
        
        if data['status'] == 'success':
            print()
            print(f"{BLUE}City: {WHITE}{data.get('city', 'N/A')}{RESET}")
            print(f"{BLUE}Country: {WHITE}{data.get('country', 'N/A')}{RESET}")
            print(f"{BLUE}Region: {WHITE}{data.get('regionName', 'N/A')}{RESET}")
            print(f"{BLUE}ZIP: {WHITE}{data.get('zip', 'N/A')}{RESET}")
            print(f"{BLUE}Latitude: {WHITE}{data.get('lat', 'N/A')}{RESET}")
            print(f"{BLUE}Longitude: {WHITE}{data.get('lon', 'N/A')}{RESET}")
            print(f"{BLUE}Timezone: {WHITE}{data.get('timezone', 'N/A')}{RESET}")
            print(f"{BLUE}ISP: {WHITE}{data.get('isp', 'N/A')}{RESET}")
            print(f"{BLUE}Organization: {WHITE}{data.get('org', 'N/A')}{RESET}")
            print(f"{BLUE}AS: {WHITE}{data.get('as', 'N/A')}{RESET}")
            
            lat = data.get('lat')
            lon = data.get('lon')
            if lat and lon:
                print(f"{GREEN}Link: {YELLOW}https://www.google.com/maps?q={lat},{lon}{RESET}")
        else:
            print(f"{RED}Error: Could not retrieve information for {ip}{RESET}")
            
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def port_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        # Validate IP address
        socket.inet_aton(ip)
        
        print(f"{CYAN}------------------ Port Scan ------------------{RESET}")
        print(f"{BLUE}{{/}} Scanning...{RESET}", end='', flush=True)
        
        # Animation while scanning
        def animate():
            chars = ['|', '/', '-', '\\']
            i = 0
            while not scan_complete.is_set():
                print(f'\r{BLUE}{{/}} Scanning... {chars[i]}{RESET}', end='', flush=True)
                i = (i + 1) % len(chars)
                time.sleep(0.2)
        
        scan_complete = threading.Event()
        animation_thread = threading.Thread(target=animate)
        animation_thread.start()
        
        # Common ports to scan
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080]
        open_ports = []
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    result = s.connect_ex((ip, port))
                    if result == 0:
                        open_ports.append(port)
            except:
                pass
        
        # Use thread pool for faster scanning
        with ThreadPoolExecutor(max_workers=50) as executor:
            executor.map(check_port, common_ports)
        
        scan_complete.set()
        animation_thread.join()
        
        print(f'\r{CYAN}------------------ Port Scan ------------------{RESET}')
        print(f"{GREEN}Ports found: {RESET}")
        
        if open_ports:
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port)
                    print(f" {GREEN}[{port}] {WHITE}- {service}{RESET}")
                except:
                    print(f" {GREEN}[{port}] {WHITE}- Unknown service{RESET}")
        else:
            print(f" {RED}No open ports found{RESET}")
            
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def service_detection():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        print(f"{CYAN}Running service detection on {ip}...{RESET}")
        
        # Use nmap for service detection if available
        try:
            result = subprocess.run(['nmap', '-sV', ip], capture_output=True, text=True, timeout=60)
            print(result.stdout)
        except:
            print(f"{YELLOW}Nmap not available. Using basic service detection.{RESET}")
            
            # Basic service detection using common ports
            common_services = {
                21: 'FTP',
                22: 'SSH',
                23: 'Telnet',
                25: 'SMTP',
                53: 'DNS',
                80: 'HTTP',
                110: 'POP3',
                143: 'IMAP',
                443: 'HTTPS',
                3306: 'MySQL',
                3389: 'RDP'
            }
            
            for port, service in common_services.items():
                try:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        result = s.connect_ex((ip, port))
                        if result == 0:
                            print(f"{GREEN}[+] {service} detected on port {port}{RESET}")
                except:
                    pass
                    
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def arp_scan():
    print(f"{CYAN}Running ARP scan on local network...{RESET}")
    
    try:
        # Try to get local IP and subnet
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        
        # Calculate subnet
        subnet = '.'.join(local_ip.split('.')[:3]) + '.0/24'
        print(f"{BLUE}Scanning subnet: {subnet}{RESET}")
        
        # Use arp-scan if available
        try:
            result = subprocess.run(['arp-scan', '--localnet'], capture_output=True, text=True)
            print(result.stdout)
        except:
            # Fallback to basic arp table
            print(f"{YELLOW}arp-scan not available. Showing current ARP table.{RESET}")
            if os.name == 'posix':  # Unix-like systems
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
                print(result.stdout)
            else:  # Windows
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
                print(result.stdout)
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def ping_sweep():
    print(f"{CYAN}Running ping sweep on local network...{RESET}")
    
    try:
        # Get local IP and subnet
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        
        subnet = '.'.join(local_ip.split('.')[:3])
        print(f"{BLUE}Sweeping subnet: {subnet}.0/24{RESET}")
        
        active_hosts = []
        
        def ping_host(host_ip):
            try:
                if os.name == 'posix':  # Unix-like systems
                    result = subprocess.run(['ping', '-c', '1', '-W', '1', host_ip], 
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        active_hosts.append(host_ip)
                        print(f"{GREEN}[+] {host_ip} is up{RESET}")
                else:  # Windows
                    result = subprocess.run(['ping', '-n', '1', '-w', '1000', host_ip], 
                                          capture_output=True, text=True, timeout=2)
                    if "Reply from" in result.stdout:
                        active_hosts.append(host_ip)
                        print(f"{GREEN}[+] {host_ip} is up{RESET}")
            except:
                pass
        
        # Ping all hosts in the subnet
        print(f"{BLUE}Scanning...{RESET}")
        with ThreadPoolExecutor(max_workers=20) as executor:
            for i in range(1, 255):
                host_ip = f"{subnet}.{i}"
                executor.submit(ping_host, host_ip)
        
        print(f"{GREEN}Scan complete. Found {len(active_hosts)} active hosts.{RESET}")
        
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def netstat():
    print(f"{CYAN}Running netstat...{RESET}")
    
    try:
        if os.name == 'posix':  # Unix-like systems
            result = subprocess.run(['netstat', '-tunap'], capture_output=True, text=True)
        else:  # Windows
            result = subprocess.run(['netstat', '-ano'], capture_output=True, text=True)
        
        print(result.stdout)
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def traceroute():
    print(f"{CYAN}{{¿}} Enter IP or hostname{RESET}")
    host = input("> ")
    
    try:
        print(f"{CYAN}Tracing route to {host}...{RESET}")
        
        if os.name == 'posix':  # Unix-like systems
            result = subprocess.run(['traceroute', host], capture_output=True, text=True)
        else:  # Windows
            result = subprocess.run(['tracert', host], capture_output=True, text=True)
        
        print(result.stdout)
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def advanced_ip_scan():
    print(f"{YELLOW}  __________________{RESET}")
    print(f"{YELLOW} /                  \\{RESET}")
    print(f"{YELLOW}|       APIS        |{RESET}")
    print(f"{YELLOW} \\__________________/{RESET}")
    print()
    
    # List of available APIs
    apis = {
        'ipapi': {
            'name': 'ipapi',
            'url': 'https://ipapi.com/',
            'key_required': True,
            'key': ''
        },
        'ipgeolocation': {
            'name': 'IP Geolocation',
            'url': 'https://ipgeolocation.io/',
            'key_required': True,
            'key': ''
        },
        'ipinfo': {
            'name': 'IPInfo',
            'url': 'https://ipinfo.io/',
            'key_required': False,
            'key': ''
        }
    }
    
    # Ask for API keys
    for api_name, api_data in apis.items():
        if api_data['key_required']:
            print(f"{CYAN}Enter {api_data['name']} API key (press Enter to skip):{RESET}")
            print(f"{GREEN}Link: {YELLOW}{api_data['url']}{RESET}")
            key = input("> ")
            if key:
                apis[api_name]['key'] = key
    
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        
        # Try each API
        for api_name, api_data in apis.items():
            if api_data['key_required'] and not api_data['key']:
                continue
                
            print(f"{CYAN}\nTrying {api_data['name']} API...{RESET}")
            
            try:
                if api_name == 'ipinfo':
                    url = f"https://ipinfo.io/{ip}/json"
                    response = requests.get(url)
                    data = response.json()
                    
                    print(f"{BLUE}IP: {WHITE}{data.get('ip', 'N/A')}{RESET}")
                    print(f"{BLUE}Hostname: {WHITE}{data.get('hostname', 'N/A')}{RESET}")
                    print(f"{BLUE}City: {WHITE}{data.get('city', 'N/A')}{RESET}")
                    print(f"{BLUE}Region: {WHITE}{data.get('region', 'N/A')}{RESET}")
                    print(f"{BLUE}Country: {WHITE}{data.get('country', 'N/A')}{RESET}")
                    print(f"{BLUE}Location: {WHITE}{data.get('loc', 'N/A')}{RESET}")
                    print(f"{BLUE}Organization: {WHITE}{data.get('org', 'N/A')}{RESET}")
                    print(f"{BLUE}Postal: {WHITE}{data.get('postal', 'N/A')}{RESET}")
                    print(f"{BLUE}Timezone: {WHITE}{data.get('timezone', 'N/A')}{RESET}")
                    
                elif api_name == 'ipapi' and api_data['key']:
                    url = f"http://api.ipapi.com/api/{ip}?access_key={api_data['key']}"
                    response = requests.get(url)
                    data = response.json()
                    
                    if 'success' in data and not data['success']:
                        print(f"{RED}API Error: {data.get('error', {}).get('info', 'Unknown error')}{RESET}")
                    else:
                        print(f"{BLUE}IP: {WHITE}{data.get('ip', 'N/A')}{RESET}")
                        print(f"{BLUE}Type: {WHITE}{data.get('type', 'N/A')}{RESET}")
                        print(f"{BLUE}Continent: {WHITE}{data.get('continent_name', 'N/A')}{RESET}")
                        print(f"{BLUE}Country: {WHITE}{data.get('country_name', 'N/A')}{RESET}")
                        print(f"{BLUE}Region: {WHITE}{data.get('region_name', 'N/A')}{RESET}")
                        print(f"{BLUE}City: {WHITE}{data.get('city', 'N/A')}{RESET}")
                        print(f"{BLUE}ZIP: {WHITE}{data.get('zip', 'N/A')}{RESET}")
                        print(f"{BLUE}Latitude: {WHITE}{data.get('latitude', 'N/A')}{RESET}")
                        print(f"{BLUE}Longitude: {WHITE}{data.get('longitude', 'N/A')}{RESET}")
                        print(f"{BLUE}Location: {WHITE}{data.get('location', {}).get('capital', 'N/A')}{RESET}")
                        
                elif api_name == 'ipgeolocation' and api_data['key']:
                    url = f"https://api.ipgeolocation.io/ipgeo?apiKey={api_data['key']}&ip={ip}"
                    response = requests.get(url)
                    data = response.json()
                    
                    print(f"{BLUE}IP: {WHITE}{data.get('ip', 'N/A')}{RESET}")
                    print(f"{BLUE}Continent: {WHITE}{data.get('continent_name', 'N/A')}{RESET}")
                    print(f"{BLUE}Country: {WHITE}{data.get('country_name', 'N/A')}{RESET}")
                    print(f"{BLUE}Region: {WHITE}{data.get('state_prov', 'N/A')}{RESET}")
                    print(f"{BLUE}City: {WHITE}{data.get('city', 'N/A')}{RESET}")
                    print(f"{BLUE}District: {WHITE}{data.get('district', 'N/A')}{RESET}")
                    print(f"{BLUE}ZIP: {WHITE}{data.get('zipcode', 'N/A')}{RESET}")
                    print(f"{BLUE}Latitude: {WHITE}{data.get('latitude', 'N/A')}{RESET}")
                    print(f"{BLUE}Longitude: {WHITE}{data.get('longitude', 'N/A')}{RESET}")
                    print(f"{BLUE}ISP: {WHITE}{data.get('isp', 'N/A')}{RESET}")
                    print(f"{BLUE}Organization: {WHITE}{data.get('organization', 'N/A')}{RESET}")
                    print(f"{BLUE}Timezone: {WHITE}{data.get('time_zone', {}).get('name', 'N/A')}{RESET}")
                    
                print(f"{CYAN}\nRaw API response:{RESET}")
                print(json.dumps(data, indent=2))
                
            except Exception as e:
                print(f"{RED}Error with {api_data['name']} API: {str(e)}{RESET}")
                
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def os_detection():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        print(f"{CYAN}Running OS detection on {ip}...{RESET}")
        
        # Use nmap for OS detection if available
        try:
            result = subprocess.run(['nmap', '-O', ip], capture_output=True, text=True, timeout=120)
            print(result.stdout)
        except:
            print(f"{YELLOW}Nmap not available. Using basic TTL-based OS detection.{RESET}")
            
            # Basic OS detection using TTL
            try:
                if os.name == 'posix':  # Unix-like systems
                    result = subprocess.run(['ping', '-c', '1', ip], capture_output=True, text=True, timeout=5)
                else:  # Windows
                    result = subprocess.run(['ping', '-n', '1', ip], capture_output=True, text=True, timeout=5)
                
                if "TTL=" in result.stdout or "ttl=" in result.stdout:
                    ttl_line = [line for line in result.stdout.split('\n') if "TTL=" in line or "ttl=" in line][0]
                    if "TTL=" in ttl_line:
                        ttl = int(ttl_line.split("TTL=")[1].split()[0])
                    else:
                        ttl = int(ttl_line.split("ttl=")[1].split()[0])
                    
                    print(f"{BLUE}TTL: {WHITE}{ttl}{RESET}")
                    
                    if ttl <= 64:
                        print(f"{BLUE}Possible OS: {WHITE}Linux/Unix{RESET}")
                    elif ttl <= 128:
                        print(f"{BLUE}Possible OS: {WHITE}Windows{RESET}")
                    else:
                        print(f"{BLUE}Possible OS: {WHITE}Network device or other{RESET}")
                else:
                    print(f"{RED}Could not determine TTL{RESET}")
                    
            except:
                print(f"{RED}Error pinging host{RESET}")
                
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def get_mac():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        
        # Try to get MAC address using ARP
        if os.name == 'posix':  # Unix-like systems
            # First ping the host to populate ARP cache
            subprocess.run(['ping', '-c', '1', '-W', '1', ip], 
                         capture_output=True, timeout=5)
            
            # Then check ARP table
            result = subprocess.run(['arp', '-n', ip], capture_output=True, text=True)
            output = result.stdout
            
            if ip in output:
                lines = output.split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            print(f"{BLUE}MAC Address: {WHITE}{parts[2]}{RESET}")
                            break
                else:
                    print(f"{RED}Could not find MAC address for {ip}{RESET}")
            else:
                print(f"{RED}Could not find MAC address for {ip}{RESET}")
                
        else:  # Windows
            # First ping the host to populate ARP cache
            subprocess.run(['ping', '-n', '1', '-w', '1000', ip], 
                         capture_output=True, timeout=5)
            
            # Then check ARP table
            result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
            output = result.stdout
            
            if ip in output:
                lines = output.split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            print(f"{BLUE}MAC Address: {WHITE}{parts[1]}{RESET}")
                            break
                else:
                    print(f"{RED}Could not find MAC address for {ip}{RESET}")
            else:
                print(f"{RED}Could not find MAC address for {ip}{RESET}")
                
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def service_info():
    print(f"{CYAN}{{¿}} Enter port number{RESET}")
    port = input("> ")
    
    try:
        port = int(port)
        if port < 1 or port > 65535:
            print(f"{RED}Error: Port must be between 1 and 65535{RESET}")
        else:
            try:
                service = socket.getservbyport(port)
                print(f"{BLUE}Service: {WHITE}{service}{RESET}")
                
                # Common service descriptions
                service_descriptions = {
                    21: "File Transfer Protocol",
                    22: "Secure Shell",
                    23: "Telnet",
                    25: "Simple Mail Transfer Protocol",
                    53: "Domain Name System",
                    80: "Hypertext Transfer Protocol",
                    110: "Post Office Protocol v3",
                    143: "Internet Message Access Protocol",
                    443: "Hypertext Transfer Protocol Secure",
                    993: "IMAP over SSL",
                    995: "POP3 over SSL",
                    3306: "MySQL Database Service",
                    3389: "Remote Desktop Protocol",
                    5432: "PostgreSQL Database Service",
                    27017: "MongoDB Database Service"
                }
                
                if port in service_descriptions:
                    print(f"{BLUE}Description: {WHITE}{service_descriptions[port]}{RESET}")
                    
            except:
                print(f"{RED}Unknown service on port {port}{RESET}")
                
    except ValueError:
        print(f"{RED}Error: Port must be a number{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def whois_lookup():
    print(f"{CYAN}{{¿}} Enter IP or domain{RESET}")
    target = input("> ")
    
    try:
        print(f"{CYAN}Running WHOIS lookup for {target}...{RESET}")
        
        # Try to use whois command if available
        try:
            if os.name == 'posix':  # Unix-like systems
                result = subprocess.run(['whois', target], capture_output=True, text=True)
            else:  # Windows (may need whois installed)
                result = subprocess.run(['whois', target], capture_output=True, text=True)
            
            print(result.stdout)
        except:
            # Fallback to online WHOIS service
            print(f"{YELLOW}Local whois command not available. Using online service.{RESET}")
            
            try:
                url = f"https://www.whois.com/whois/{target}"
                print(f"{GREEN}Link: {YELLOW}{url}{RESET}")
                
                # You could use requests with a proper WHOIS API here
                print(f"{YELLOW}Please visit the above link for WHOIS information.{RESET}")
                
            except Exception as e:
                print(f"{RED}Error: {str(e)}{RESET}")
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def nmap_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        print(f"{CYAN}Running Nmap scan on {ip}...{RESET}")
        
        # Check if nmap is available
        try:
            result = subprocess.run(['nmap', '-v', '-A', ip], capture_output=True, text=True, timeout=300)
            print(result.stdout)
            
            if result.stderr:
                print(f"{RED}Errors:{RESET}")
                print(result.stderr)
                
        except FileNotFoundError:
            print(f"{RED}Nmap is not installed. Please install nmap to use this feature.{RESET}")
        except subprocess.TimeoutExpired:
            print(f"{RED}Nmap scan timed out.{RESET}")
            
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def tcp_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        print(f"{CYAN}Running TCP scan on {ip}...{RESET}")
        
        # Common TCP ports to scan
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080]
        open_ports = []
        
        print(f"{BLUE}Scanning...{RESET}", end='', flush=True)
        
        def animate():
            chars = ['|', '/', '-', '\\']
            i = 0
            while not scan_complete.is_set():
                print(f'\r{BLUE}Scanning... {chars[i]}{RESET}', end='', flush=True)
                i = (i + 1) % len(chars)
                time.sleep(0.2)
        
        scan_complete = threading.Event()
        animation_thread = threading.Thread(target=animate)
        animation_thread.start()
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    result = s.connect_ex((ip, port))
                    if result == 0:
                        open_ports.append(port)
            except:
                pass
        
        # Use thread pool for faster scanning
        with ThreadPoolExecutor(max_workers=50) as executor:
            executor.map(check_port, common_ports)
        
        scan_complete.set()
        animation_thread.join()
        
        print(f'\r{CYAN}TCP Scan Results:{RESET}')
        
        if open_ports:
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port)
                    print(f" {GREEN}[{port}/TCP] {WHITE}- {service}{RESET}")
                except:
                    print(f" {GREEN}[{port}/TCP] {WHITE}- Unknown service{RESET}")
        else:
            print(f" {RED}No open TCP ports found{RESET}")
            
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def udp_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    try:
        socket.inet_aton(ip)
        print(f"{CYAN}Running UDP scan on {ip}...{RESET}")
        print(f"{YELLOW}Note: UDP scanning can be slow and unreliable.{RESET}")
        
        # Common UDP ports to scan
        common_ports = [53, 67, 68, 69, 123, 135, 137, 138, 139, 161, 162, 445, 514, 631, 1434, 1900, 4500, 49152]
        open_ports = []
        
        print(f"{BLUE}Scanning...{RESET}", end='', flush=True)
        
        def animate():
            chars = ['|', '/', '-', '\\']
            i = 0
            while not scan_complete.is_set():
                print(f'\r{BLUE}Scanning... {chars[i]}{RESET}', end='', flush=True)
                i = (i + 1) % len(chars)
                time.sleep(0.2)
        
        scan_complete = threading.Event()
        animation_thread = threading.Thread(target=animate)
        animation_thread.start()
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                    s.settimeout(1)
                    # Send empty data to trigger response
                    s.sendto(b'', (ip, port))
                    try:
                        data, addr = s.recvfrom(1024)
                        open_ports.append(port)
                    except socket.timeout:
                        # Port might be open but not responding
                        pass
            except:
                pass
        
        # Use thread pool for faster scanning
        with ThreadPoolExecutor(max_workers=20) as executor:
            executor.map(check_port, common_ports)
        
        scan_complete.set()
        animation_thread.join()
        
        print(f'\r{CYAN}UDP Scan Results:{RESET}')
        
        if open_ports:
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port, 'udp')
                    print(f" {GREEN}[{port}/UDP] {WHITE}- {service}{RESET}")
                except:
                    print(f" {GREEN}[{port}/UDP] {WHITE}- Unknown service{RESET}")
        else:
            print(f" {RED}No responsive UDP ports found{RESET}")
            
    except socket.error:
        print(f"{RED}Error: Invalid IP address{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def trace_path():
    print(f"{CYAN}{{¿}} Enter IP or hostname{RESET}")
    host = input("> ")
    
    try:
        print(f"{CYAN}Tracing path to {host}...{RESET}")
        
        if os.name == 'posix':  # Unix-like systems
            result = subprocess.run(['tracepath', host], capture_output=True, text=True)
        else:  # Windows
            result = subprocess.run(['tracert', host], capture_output=True, text=True)
        
        print(result.stdout)
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def version():
    print(f"{CYAN}IpHub Version Information{RESET}")
    print(f"{BLUE}Version: {WHITE}0.Beta{RESET}")
    print(f"{BLUE}Author: {WHITE}marzi tools{RESET}")
    print(f"{BLUE}Description: {WHITE}Network analysis and information gathering tool{RESET}")
    print(f"{BLUE}License: {WHITE}For educational purposes only{RESET}")
    
    input("\nPress Enter to continue...")

def main():
    while True:
        print_banner()
        print_menu()
        
        try:
            choice = input(f"{CYAN}{{#}} >{RESET} ").strip()
            
            if choice == '1':
                ip_info()
            elif choice == '2':
                port_scan()
            elif choice == '3':
                service_detection()
            elif choice == '4':
                arp_scan()
            elif choice == '5':
                ping_sweep()
            elif choice == '6':
                netstat()
            elif choice == '7':
                traceroute()
            elif choice == '8':
                advanced_ip_scan()
            elif choice == '9':
                os_detection()
            elif choice == '10':
                get_mac()
            elif choice == '11':
                service_info()
            elif choice == '12':
                whois_lookup()
            elif choice == '13':
                nmap_scan()
            elif choice == '14':
                tcp_scan()
            elif choice == '15':
                udp_scan()
            elif choice == '16':
                trace_path()
            elif choice == '17':
                version()
            elif choice.lower() == 'exit' or choice.lower() == 'quit':
                print(f"{GREEN}Goodbye!{RESET}")
                break
            else:
                print(f"{RED}Invalid choice. Please try again.{RESET}")
                time.sleep(1)
                
        except KeyboardInterrupt:
            print(f"\n{GREEN}Goodbye!{RESET}")
            break
        except Exception as e:
            print(f"{RED}Error: {str(e)}{RESET}")
            time.sleep(2)

if __name__ == "__main__":
    main()
